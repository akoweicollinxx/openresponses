/**
 * Generated by Kubb (https://kubb.dev/).
 * Do not edit manually.
 */

import { includeEnumSchema } from "./includeEnumSchema.ts";
import { itemParamSchema } from "./itemParamSchema.ts";
import { metadataParamSchema } from "./metadataParamSchema.ts";
import { reasoningParamSchema } from "./reasoningParamSchema.ts";
import { responsesToolParamSchema } from "./responsesToolParamSchema.ts";
import { serviceTierEnumSchema } from "./serviceTierEnumSchema.ts";
import { streamOptionsParamSchema } from "./streamOptionsParamSchema.ts";
import { textParamSchema } from "./textParamSchema.ts";
import { toolChoiceParamSchema } from "./toolChoiceParamSchema.ts";
import { truncationEnumSchema } from "./truncationEnumSchema.ts";
import { z } from "zod";

export const createResponseBodySchema = z.object({
  model: z.optional(z.union([z.string(), z.null()])),
  input: z.optional(
    z.union([
      z.union([z.array(z.lazy(() => itemParamSchema)), z.string()]),
      z.null(),
    ]),
  ),
  previous_response_id: z.optional(z.union([z.string(), z.null()])),
  include: z.optional(z.array(z.lazy(() => includeEnumSchema))),
  tools: z.optional(
    z.union([z.array(z.lazy(() => responsesToolParamSchema)), z.null()]),
  ),
  tool_choice: z.optional(
    z.union([z.lazy(() => toolChoiceParamSchema).and(z.any()), z.null()]),
  ),
  metadata: z.optional(
    z.union([z.lazy(() => metadataParamSchema).and(z.any()), z.null()]),
  ),
  text: z.optional(
    z.union([z.lazy(() => textParamSchema).and(z.any()), z.null()]),
  ),
  temperature: z.optional(z.union([z.number(), z.null()])),
  top_p: z.optional(z.union([z.number(), z.null()])),
  presence_penalty: z.optional(z.union([z.number(), z.null()])),
  frequency_penalty: z.optional(z.union([z.number(), z.null()])),
  parallel_tool_calls: z.optional(z.union([z.boolean(), z.null()])),
  stream: z.optional(
    z
      .boolean()
      .describe("Whether to stream response events as server-sent events."),
  ),
  stream_options: z.optional(
    z.union([z.lazy(() => streamOptionsParamSchema).and(z.any()), z.null()]),
  ),
  background: z.optional(
    z
      .boolean()
      .describe(
        "Whether to run the request in the background and return immediately.",
      ),
  ),
  max_output_tokens: z.optional(z.union([z.number().int(), z.null()])),
  max_tool_calls: z.optional(z.union([z.number().int(), z.null()])),
  reasoning: z.optional(
    z.union([z.lazy(() => reasoningParamSchema).and(z.any()), z.null()]),
  ),
  safety_identifier: z.optional(z.union([z.string(), z.null()])),
  prompt_cache_key: z.optional(z.union([z.string(), z.null()])),
  truncation: z.optional(z.lazy(() => truncationEnumSchema).and(z.any())),
  instructions: z.optional(z.union([z.string(), z.null()])),
  store: z.optional(
    z
      .boolean()
      .describe("Whether to store the response so it can be retrieved later."),
  ),
  service_tier: z.optional(z.lazy(() => serviceTierEnumSchema).and(z.any())),
  top_logprobs: z.optional(z.union([z.number().int(), z.null()])),
});
